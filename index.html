<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NAEI Multi-Group Pollutant Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://www.gstatic.com/charts/loader.js"></script>

  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; color: #000; background:#fff; }
    label { font-weight:600; margin-right:6px; }
    select, button { margin:6px; padding:6px 10px; border-radius:6px; border:1px solid #ccc; }
    h2 { margin-bottom:8px; }

    #groupContainer { margin-top:10px; }
    .groupRow { display:flex; align-items:center; gap:8px; margin:4px 0; }
    .groupRow.dragging { opacity:0.5; }

    /* Chart is hidden until fully drawn at correct size */
    #chart_div { width:100%; height:70vh; margin-top:20px; opacity:0; transition:opacity .35s ease; min-height:60vh; }
    #chart_div.visible { opacity:1; }

    button { background:#EFEFEF; cursor:pointer; }
    button:hover { background:#E0E0E0; }
    button:disabled { background:#EEE; color:#666; cursor:not-allowed; }

    .add-btn, .remove-btn { display:inline-flex; align-items:center; gap:6px; }
    .remove-icon { display:inline-block; width:18px; height:18px; border-radius:50%; background:#d33; color:#fff; text-align:center; line-height:18px; font-weight:bold; }

    /* Loader overlay + pie spinner */
    #loadingOverlay {
      position:fixed; top:0; left:0; width:100%; height:100%;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      background: rgba(255,255,255,0.98); z-index:9999; transition:opacity .35s ease;
    }
    .spinner {
      width:96px; height:96px; border-radius:50%;
      background: conic-gradient(#E6194B 0deg 120deg, #F58231 120deg 240deg, #FFE119 240deg 360deg);
      animation: spin 1.25s linear infinite; box-shadow:0 0 12px rgba(0,0,0,0.08);
    }
    @keyframes spin { from { transform:rotate(0deg); } to { transform:rotate(360deg); } }
    .loading-text { margin-top:12px; color:#333; font-weight:600; }

    #mainContent { display:none; opacity:0; transition:opacity .4s ease; }
    #mainContent.loaded { opacity:1; }
  </style>
</head>

<body>
  <div id="loadingOverlay">
    <div class="spinner" aria-hidden="true"></div>
    <div class="loading-text">Loading data, please wait…</div>
  </div>

  <div id="mainContent" aria-hidden="true">
    <h2>NAEI Multi-Group Pollutant Viewer</h2>

    <div>
      <label for="pollutantSelect">Pollutant:</label>
      <select id="pollutantSelect" name="pollutantSelect"><option value="">Select pollutant</option></select>
    </div>

    <div id="groupContainer"></div>

    <div>
      <label for="startYear">Start Year:</label>
      <select id="startYear" name="startYear"></select>

      <label for="endYear">End Year:</label>
      <select id="endYear" name="endYear"></select>

      <button id="downloadBtn">⬇️ Download Chart as PNG</button>
    </div>

    <div id="chart_div" role="img" aria-label="Pollutant time series chart"></div>
  </div>

  <script>
    // Load Google Charts
    google.charts.load('current', { packages: ['corechart'] });

    // JSON (gviz/tq) endpoints — your original working URLs
    const DATA_SHEET_URL =
      'https://docs.google.com/spreadsheets/d/1m0as8iV7quPhM5fg_8fJpzAEQh_LBBDFwnuzf71QJZM/gviz/tq?sheet=23ds_group_data&tq=SELECT%20*';
    const UNIT_SHEET_URL =
      'https://docs.google.com/spreadsheets/d/1m0as8iV7quPhM5fg_8fJpzAEQh_LBBDFwnuzf71QJZM/gviz/tq?sheet=Pollutant&tq=SELECT%20*';

    let globalRows = [];
    let globalHeaders = [];
    let pollutantUnits = {};
    let groupedData = {};

    // -----------------------
    // Stable colour system
    // -----------------------
    const distinctPalette = [
      '#E6194B','#3CB44B','#FFE119','#4363D8','#F58231',
      '#911EB4','#46F0F0','#F032E6','#BCF60C','#FABEBE'
    ];

    // Preferred base colours for categories (kept if available)
    const categoryBaseColor = {
      ecodesign: distinctPalette[4], // orange
      fireplace: distinctPalette[0], // red
      gas: distinctPalette[3],       // blue
      power: distinctPalette[1],     // green
      road: distinctPalette[6]       // cyan
    };

    // colourCache: groupName -> hex (stable across redraws)
    // availableColors: pool of colours not currently assigned
    let colorCache = {};
    let availableColors = [...distinctPalette];

    function resetColorSystem() {
      colorCache = {};
      availableColors = [...distinctPalette];
    }

    function getColorForGroup(groupName) {
      if (!groupName) return '#888888';
      if (colorCache[groupName]) return colorCache[groupName];

      const lower = groupName.toLowerCase();
      const category = Object.keys(categoryBaseColor).find(c => lower.includes(c));
      let color = null;

      // If category has a preferred color and it's free, use it
      if (category) {
        const base = categoryBaseColor[category];
        if (availableColors.includes(base)) {
          color = base;
          // remove from pool
          availableColors = availableColors.filter(c => c !== base);
        }
      }

      // Otherwise use next available color
      if (!color) {
        color = availableColors.shift() || '#888888';
      }

      colorCache[groupName] = color;
      return color;
    }

    // Rebuild color assignments when the active groups list changes:
    // - try to preserve previous assignment where possible
    // - free colours that are no longer in use
    function refreshColorAssignments(groups) {
      const prevCache = { ...colorCache };
      resetColorSystem();

      // Reassign previous colours if still applicable and free
      groups.forEach(g => {
        if (prevCache[g] && availableColors.includes(prevCache[g])) {
          colorCache[g] = prevCache[g];
          availableColors = availableColors.filter(c => c !== prevCache[g]);
        }
      });

      // Assign colours for groups without one
      groups.forEach(g => {
        if (!colorCache[g]) getColorForGroup(g);
      });
    }

    // -----------------------
    // Fetch Google Visualization JSON
    // -----------------------
    async function fetchGVizData(url) {
      const res = await fetch(url);
      const text = await res.text();
      if (!text.startsWith('/*O_o*/')) throw new Error('Sheet not accessible.');
      // extract JSON object inside the callback
      return JSON.parse(text.substring(text.indexOf('{'), text.lastIndexOf('}') + 1));
    }

    async function loadUnits() {
      const json = await fetchGVizData(UNIT_SHEET_URL);
      json.table.rows.forEach(r => {
        const cells = r.c.map(c => (c ? c.v : null));
        if (cells[0] && cells[1]) pollutantUnits[cells[0]] = cells[1];
      });
    }

    async function loadData() {
      const json = await fetchGVizData(DATA_SHEET_URL);
      const headers = json.table.cols.map(c => c.label);
      const rows = json.table.rows.map(r => r.c.map(c => (c ? c.v : null)));
      globalHeaders = headers;
      globalRows = rows;
      groupedData = {};
      rows.forEach(row => {
        const group = row[0];
        const pollutant = row[1];
        if (!groupedData[pollutant]) groupedData[pollutant] = {};
        groupedData[pollutant][group] = row;
      });
    }

    // -----------------------
    // UI setup
    // -----------------------
    function setupSelectors() {
      const pollutants = [...new Set(globalRows.map(r => r[1]))].sort((a,b) => a.localeCompare(b));
      const select = document.getElementById("pollutantSelect");
      pollutants.forEach(p => select.add(new Option(p, p)));

      const headers = globalHeaders.slice(2);
      const years = headers.map(h => h.replace(/^f/, ""));
      const start = document.getElementById("startYear");
      const end = document.getElementById("endYear");
      years.forEach(y => {
        start.add(new Option(y, y));
        end.add(new Option(y, y));
      });
      start.value = years[0];
      end.value = years[years.length - 1];

      select.addEventListener("change", updateChart);
      start.addEventListener("change", updateChart);
      end.addEventListener("change", updateChart);
    }

    function addGroupSelector(defaultValue = "") {
      const container = document.getElementById("groupContainer");
      const div = document.createElement("div");
      div.className = "groupRow";
      div.draggable = true;

      const groupSelect = document.createElement("select");
      groupSelect.innerHTML = '<option value="">Select group</option>';
      const allGroups = [...new Set(globalRows.map(r => r[0]))].sort((a,b) => a.localeCompare(b));
      allGroups.forEach(g => groupSelect.add(new Option(g, g)));
      if (defaultValue) groupSelect.value = defaultValue;
      groupSelect.addEventListener("change", updateChart);

      const dragHandle = document.createElement("span");
      dragHandle.textContent = "⠿";
      dragHandle.style.cursor = "grab";
      dragHandle.style.marginRight = "6px";

      div.appendChild(dragHandle);
      div.appendChild(groupSelect);
      container.appendChild(div);

      addDragAndDropHandlers(div);
      refreshButtons();
    }

    function refreshButtons() {
      const container = document.getElementById("groupContainer");
      container.querySelectorAll(".add-btn, .remove-btn").forEach(btn => btn.remove());
      const groups = container.querySelectorAll(".groupRow");

      if (groups.length > 1) {
        groups.forEach(div => {
          if (!div.querySelector(".remove-btn")) {
            const removeBtn = document.createElement("button");
            removeBtn.className = "remove-btn";
            removeBtn.innerHTML = `<span class="remove-icon">−</span> Remove Group`;
            removeBtn.onclick = () => {
              div.remove();
              refreshButtons();
              updateChart();
            };
            div.appendChild(removeBtn);
          }
        });
      }

      const addBtn = document.createElement("button");
      addBtn.className = "add-btn";
      addBtn.innerHTML = `<span class="add-icon">+</span> Add Group`;
      if (groups.length >= 10) {
        addBtn.textContent = "Max Groups = 10";
        addBtn.disabled = true;
      } else {
        addBtn.onclick = () => addGroupSelector();
      }
      container.appendChild(addBtn);
    }

    function addDragAndDropHandlers(div) {
      div.addEventListener("dragstart", e => {
        e.dataTransfer.setData("text/plain", "");
        div.classList.add("dragging");
      });
      div.addEventListener("dragend", () => div.classList.remove("dragging"));
      div.addEventListener("dragover", e => {
        e.preventDefault();
        const container = document.getElementById("groupContainer");
        const dragging = document.querySelector(".dragging");
        const after = getDragAfterElement(container, e.clientY);
        const addBtn = container.querySelector(".add-btn");
        if (after == null || after === addBtn) container.insertBefore(dragging, addBtn);
        else container.insertBefore(dragging, after);
      });
      div.addEventListener("drop", updateChart);
    }

    function getDragAfterElement(container, y) {
      const draggable = [...container.querySelectorAll(".groupRow:not(.dragging)")];
      return draggable.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) return { offset, element: child };
        else return closest;
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function getSelectedGroups() {
      return [...document.querySelectorAll("#groupContainer select")].map(s => s.value).filter(Boolean);
    }

    // -----------------------
    // Chart drawing (stable scaling)
    // -----------------------
    function updateChart() {
      const pollutant = document.getElementById("pollutantSelect").value;
      const startYear = +document.getElementById("startYear").value;
      const endYear = +document.getElementById("endYear").value;
      const groups = getSelectedGroups();
      if (!pollutant || !startYear || !endYear || !groups.length) return;

      // Refresh colour assignments (preserve old assignments where possible)
      refreshColorAssignments(groups);

      const headers = globalHeaders;
      const startCol = headers.findIndex(h => h.toLowerCase() === `f${startYear}`);
      const endCol = headers.findIndex(h => h.toLowerCase() === `f${endYear}`);
      if (startCol === -1 || endCol === -1) return;

      const years = headers.slice(startCol, endCol + 1).map(h => h.replace(/^f/, ""));
      const chartCols = ['Year'];
      const chartRows = years.map(y => [y]);

      // colours in order per group (use colorCache)
      const colors = groups.map(g => colorCache[g] || getColorForGroup(g));

      groups.forEach((g, gi) => {
        const dataRow = groupedData[pollutant]?.[g];
        chartCols.push(g + " (black)");
        chartCols.push(g);
        years.forEach((yr, yi) => {
          const raw = dataRow ? dataRow[startCol + yi] : null;
          const value = (raw === null || raw === undefined) ? null : parseFloat(raw);
          const val = (value === null || Number.isNaN(value)) ? null : value;
          chartRows[yi].push(val);
          chartRows[yi].push(val);
        });
      });

      const dataArray = [chartCols].concat(chartRows);
      const dataTable = google.visualization.arrayToDataTable(dataArray);

      const unit = pollutantUnits[pollutant] || "";
      const values = chartRows.flatMap(r => r.slice(1).filter(v => v != null));
      const maxVal = values.length ? Math.max(...values) : 0;
      const upperLimit = maxVal > 0 ? maxVal * 1.15 : 1;

      const seriesOptions = {};
      groups.forEach((g, gi) => {
        const baseIndex = gi * 2;
        seriesOptions[baseIndex] = { color: '#000', lineWidth: 5, visibleInLegend: false, pointSize: 0 };
        seriesOptions[baseIndex + 1] = { color: colors[gi], lineWidth: 3, visibleInLegend: true, pointSize: 4 };
      });

      const options = {
        title: `${pollutant}${unit ? " (" + unit + ")" : ""}`,
        legend: { position: 'bottom' },
        hAxis: { title: 'Year' },
        vAxis: { title: `Emissions${unit ? " (" + unit + ")" : ""}`, viewWindow: { min: 0, max: upperLimit } },
        chartArea: { width: '80%', height: '70%' },
        curveType: 'function',
        series: seriesOptions
      };

      const chart = new google.visualization.LineChart(document.getElementById('chart_div'));
      chart.draw(dataTable, options);

      // Ensure chart container visible (fade-in) after draw
      const chartDiv = document.getElementById('chart_div');
      setTimeout(() => chartDiv.classList.add('visible'), 120);

      // download
      document.getElementById('downloadBtn').onclick = () => {
        const link = document.createElement('a');
        link.href = chart.getImageURI();
        link.download = `${pollutant}_comparison.png`;
        link.click();
      };
    }

    // -----------------------
    // Initialization & loader control
    // -----------------------
    async function init() {
      try {
        await loadUnits();
        await loadData();
      } catch (err) {
        console.error("Failed loading data:", err);
        const overlay = document.getElementById('loadingOverlay');
        overlay.innerHTML = '<div style="color:#900;font-weight:700">Failed to load data — check sheet access.</div>';
        return;
      }

      // Setup UI
      setupSelectors();
      addGroupSelector("All");
      document.getElementById('pollutantSelect').value = 'PM2.5';

      // Fade out loader and show content, then draw chart properly sized
      const overlay = document.getElementById('loadingOverlay');
      const content = document.getElementById('mainContent');
      overlay.style.opacity = '0';
      setTimeout(() => {
        overlay.style.display = 'none';
        content.style.display = 'block';
        setTimeout(() => {
          content.classList.add('loaded');
          // draw chart after layout is visible so Google Charts sizes it correctly
          setTimeout(() => {
            updateChart();
          }, 200);
        }, 50);
      }, 400);
    }

    document.addEventListener('DOMContentLoaded', () => {
      google.charts.setOnLoadCallback(init);
    });
  </script>
</body>
</html>
